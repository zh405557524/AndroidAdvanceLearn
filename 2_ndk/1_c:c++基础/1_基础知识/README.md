# 基础知识

##  一 、函数

* 定义：函数是一组一起执行一个任务的语句。每个C程序都至少有一个函数，即主函数main(),所有简单的程序都可以定义其他额外的函数。
* 函数定义

~~~c
return_type function_name(parameter list)
{
  body of the function
}
~~~

* 指针函数

  * 定义：指针函数是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针。

    如：类型标识符 *函数名(参数表)

    ​    int *f(x,y);

* 函数指针

  * 定义：函数指针是指向函数的指针变量，即本质是一个指针变量。

     如：int(* f) (int x);/* * 声明一个函数指针*/

    ​         func;/* 将func函数的首地址赋给指针f*/

## 二、Linux内存布局原理

* 内存定义：

  * 硬件角度：内存是计算机必不可少的一个组成部分，是于cpu沟通的桥梁，计算机所有的程序运行在内存中的。
  * 逻辑角度:内存是一块具备随机访问能力，支持读、写操作，用来存放程序及程序运行中产生的数据的区域。、

* 内存

  * 内存单位

    * 位 ：bit 是电子计算中最小的数据单位。每一位的状态只能是0或1
    * 字节：1byte = 8 bit ,是内存基本的计量单位。
    * kb ： 1kb = 1024Byte.
    * mb: 1mb = 1024kb.类型的还有gb，tb。

  * 内存编址

    * 内存编址：计算机中的内存按字节编址，每个地址的存储单位可以存放一个字节(8 bit) 的数据，cpu通过内存地址获取指令和数据，并不关心这个地址所代表的控件具体在什么位置、怎么分布，因为硬件的设计保证一个地址对应着一个固定的控件，所有说：内存地址和地址指向的空间共同构成一个内存单元。

  * 内存地址

    * 内存地址：内存地址通常用十六进制的数据表示，指向内存中某一块区域。

    * 内存分配规则：内存分配规则是连续的，一个挨着一个。当对象需要申请内存时，先给这个对象分配一个编码，这个编码就是内存地址。

  * 内存对象

    * 指针指向的内存区域能存储不同的类型

  * 基本数据类型

    * int(4字节)
    * short(2 字节)
    * long(4字节)
    * char(1字节)
    * double(8字节)
    * Long double(10字节)
    * 引用类型

  * 内存组成

    * android内存组成

      * 类加载器子系统->方法区、堆内存、java栈 、pc寄存器、本地方法栈（运行时数据区）->即时编译器、垃圾回收(执行引擎)->本地方法接口->本地方法区

    * c语音内存组成

      * 堆    (运行时系统分配空间)

      * 栈

      * BSS段  (编译时由编译器分配空间)

      * 数据段

      * 代码段

        

## 三、数组和指针

* 指针优先级
  
  * 定义：()>[]>*
  
* 数组指针(也称为行指针)

  * 定义：int (*p)[n]

     优先级，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。

    int a [3] [4 ];

    int (*p)[4];//该语句是定义一个数组指针，指向含4个元素的一维数组。

    p=a; //将该二维数组的首地址赋予p，也就是a[0]或&a[0] [0]

    p++; //该语句执行过后，也就是p=p+1;p跨过行a[0] [] 指向了行a[1] []

## 四、结构体

* 定义：

  ~~~c
  // Student 相当于类名
  // student 和a 可以不定义，表示结构变量，也就是student类型的变量
  struct Student
  {
    	char name[50];
    	int age;
  }Student,a;
  
  //使用typede 定义
  typedef struct{
    char name[50];
    int age;
  }Student;
  
  ~~~



* 内存对齐
  
* 定义：对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度整数倍，他就被称做自然对齐。比如在32位cpu下，假设一个整形变量的地址为0x00000004，那它就是自然对齐的。
  
* 结构体大小
  
* 定义：当结构体需要内存过大，使用动态内存申请。结构体占用字节数和结构体内字段有关，指针占用内存就是4/8字节，因此传指针比传值效率更高。
  
* 结构体存储原则
  * 1 结构体变量中成员的偏移量必须是成员大小的整数倍(0倍认为是任何数的整数倍)
  * 结构大小必须是成员大小的整数倍，也即所有成员大小的公倍数。

* 结构体

  ~~~c
  struct stu1{
    char c1;
    int i;
    char c2;
  }
  ~~~

  * 为什么：因为在32位操作系统(虽然64位操作系统，但为了保证兼容性，编程仍然主要考量32位)中，数据总线是32位，地址总线是23位。地址总线是32位，意味着寻地址空间是按4递增的；数据总线32位意味着一次可读写4byte。

- 共用体

  * 定义：共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同内存位置的有效方式。

  * 写法

    ~~~c
    union Data{
      int i;
      float f;
      char str[20];
    }data;
    ~~~

    * 注意共用体占用的内存应足够存储共用体中最大的成员。例如,在上面的实例中，data将占用20个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。

      



## so动态库与编译

* 库的概念
  * 定义：在windows平台和linux平台下都大量存在着库。Android中也存在库，库顾名思义，值得是一个容器文件，里面装的是函数，由于windows和linux的平台不同(主要是编译器、汇编器和连机器的不同)，因此二者库的二进制是不兼容的。
* 库存在的意义
  * 定义：苦事别人写好的现有的，成熟的，可以服用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。
* 库的种类
  * 动态库 .so/.dll
  * 静态库 .a/.lib
* 如果编译一个动态库
  * 预编译->编译->汇编->链接
  * 静态库、动态库区别来自[链接阶段]如果处理库，链接可执行程序。分别称为静态链接、动态链接方式。
* 动态库与静态库的区别
  * 静态库文件比较大，动态库比较小
  * 静态库需要在编译时 被链接在目标代码中，动态库在运行时才会被加载到目标代码
  * 静态库类似Android中的Module，一旦打包APK需要重新进行编译。
  * 动态库类似于jar包 打包是不需要重新进行编译。

































